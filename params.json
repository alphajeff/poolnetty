{"name":"Poolnetty","tagline":"Netty client pooling.","body":"Pool Netty\r\n==========\r\n\r\n[Netty](http://netty.io) client connection pooling.\r\n\r\nState:\r\n------\r\n16-Mar-2014: Renamed packages to reflect Maven group prefix 'org.r358.' Fixed Javadoc. Created Release 0.1.0\r\n\r\n\r\nGetting:\r\n--------\r\n\r\n16-Mar-2014: This is in the throws of getting pushed into jcenter and the central maven repo.\r\n\r\nHosted in [Bintray:](https://bintray.com) at (https://bintray.com/r358org/poolnetty/org.r358.poolnetty/)\r\n\r\n```xml\r\n\r\n    <dependency>\r\n    <groupId>org.r358.poolnetty</groupId>\r\n    <artifactId>common</artifactId>\r\n    <version>0.1.0.Final</version>\r\n    <type>jar</type>\r\n    </dependency>\r\n\r\n    <dependency>\r\n    <groupId>org.r358.poolnetty</groupId>\r\n    <artifactId>pool</artifactId>\r\n    <version>0.1.0.Final</version>\r\n    <type>jar</type>\r\n    </dependency>\r\n\r\n```\r\n\r\n\r\n\r\nBuilding:\r\n---------\r\n\r\nDownload and install [Gradle](http://www.gradle.org)\r\n\r\n\r\nTo build and produce coverage report:\r\n\r\n```\r\n   gradle clean test coverage_report\r\n\r\n   # Build will print absolute path to coverage report, open it in your browser.\r\n\r\n```\r\n\r\n\r\n## Using:\r\nUse the following to get you started quickly.\r\n\r\n### Basic set up.\r\n\r\n```java\r\n\r\n NettyConnectionPoolBuilder ncb = new NettyConnectionPoolBuilder(immortalCount, maxEphemeral, ephemeralLifespanMillis);\r\n\r\n\r\n         final EventLoopGroup elg = new NioEventLoopGroup();\r\n\r\n\r\n         //\r\n         // Create the boot strap.\r\n         //\r\n         ncb.withBootstrapProvider(new BootstrapProvider()\r\n         {\r\n             @Override\r\n             public Bootstrap createBootstrap(PoolProvider poolProvider)\r\n             {\r\n                 Bootstrap bs = new Bootstrap();\r\n                 bs.group(elg);\r\n                 bs.channel(NioSocketChannel.class);\r\n                 bs.option(ChannelOption.SO_KEEPALIVE, true);\r\n                 bs.option(ChannelOption.AUTO_READ, true);\r\n                 return bs;\r\n             }\r\n         });\r\n\r\n\r\n         //\r\n         // Sets up the connection info and the channel initializer.\r\n         //\r\n         ncb.withConnectionInfoProvider(new ConnectionInfoProvider()\r\n         {\r\n             @Override\r\n             public ConnectionInfo connectionInfo(PoolProvider poolProvider)\r\n             {\r\n\r\n                 return new ConnectionInfo(new InetSocketAddress(\"127.0.0.1\", 1887), null, new ChannelInitializer()\r\n                 {\r\n                     @Override\r\n                     protected void initChannel(Channel ch)\r\n                         throws Exception\r\n                     {\r\n                         ch.pipeline().addLast(\"decode\", new SimpleInboundHandler(10));\r\n                         ch.pipeline().addLast(\"encode\", new SimpleOutboundHandler(10));\r\n                     }\r\n                 });\r\n\r\n\r\n             }\r\n         });\r\n\r\n\r\n         //\r\n         // Make the pool add listener and start.\r\n         //\r\n         NettyConnectionPool ncp = ncb.build();\r\n\r\n         //\r\n         // Start the pool.\r\n         //\r\n\r\n         ncp.start();\r\n\r\n```\r\n\r\n### Obtain a lease\r\nThere are three ways to obtain a lease.\r\n\r\n```java\r\n\r\n //\r\n // Blocking\r\n //\r\n\r\n   LeasedChannel chan = ncp.lease(10, TimeUnit.Seconds, userObject);\r\n\r\n //\r\n // Using a future.\r\n //\r\n\r\n  Future<LeasedChannel> chanFuture = ncp.leaseAsync(10, TimeUnit.DAYS, userObject);\r\n\r\n  //\r\n  // Using a callback. (You also get back future.)\r\n  //\r\n\r\n  ncp.leaseAsync(10, TimeUnit.DAYS, userObject, new LeaseListener()\r\n        {\r\n            @Override\r\n            public void leaseRequest(boolean success, LeasedChannel channel, Throwable th)\r\n            {\r\n              // Do work..\r\n            }\r\n        });\r\n\r\n\r\n```\r\n\r\n### Canceling lease requests\r\nYou can call Future#cancel() and it will try to cancel the lease request on a best effort basis.\r\n\r\n\r\n\r\n### Yield a lease\r\nYielding a lease means giving it back to the pool.\r\n\r\n```java\r\n\r\n //\r\n // Directly back to the pool.\r\n //\r\n\r\n ncp.yield(chan);\r\n\r\n //\r\n // From instances of LeasedChannel\r\n //\r\n\r\n chan.yield();\r\n\r\n```\r\n\r\n## Getting notification\r\n\r\n## Events from the pool\r\nImplement PoolProviderListener directly or extend PoolProviderListenerAdapter to receive notification of events generate by the pool.\r\n\r\nFor Example using the Adapter to keep code size down.\r\n\r\n```java\r\n  NettyConnectionPool ncc =\r\n  ncp.addListener(new PoolProviderListenerAdapter()\r\n         {\r\n\r\n             @Override\r\n             public void connectionCreated(PoolProvider provider, Channel channel, boolean immortal)\r\n             {\r\n                 openedConnections.countDown();\r\n             }\r\n\r\n             @Override\r\n             public void leaseGranted(PoolProvider provider, Channel channel, Object userObject)\r\n             {\r\n                 leaseAll.countDown();\r\n             }\r\n\r\n             @Override\r\n             public void leaseYield(PoolProvider provider, Channel channel, Object userObject)\r\n             {\r\n                 yieldedConnections.countDown();\r\n             }\r\n\r\n             @Override\r\n             public void connectionClosed(PoolProvider provider, Channel channel)\r\n             {\r\n                 closedConnections.countDown();\r\n             }\r\n         });\r\n\r\n```\r\n\r\n## Events from the LeasedChannel\r\n\r\nLeasedChannel transparently wraps the Netty Channel and adds a void yield() and onLeaseExpire() methods.\r\nUsers can get direct notification of lease expiration by supplying a implementation of ValueEvent<Leasee>.\r\n\r\nFor Example:\r\n\r\n```java\r\n     lchan.onLeaseExpire(new ValueEvent<Leasee>()\r\n            {\r\n                @Override\r\n                public void on(Leasee value)\r\n                {\r\n                    // Expired.\r\n                }\r\n            });\r\n\r\n```\r\n\r\n*Note:*\r\nOnly a single ValueEvent<Lease> can be used, this is not an accumulative list of listeners.\r\n\r\n\r\n\r\n## Interfaces\r\nAs Netty is so configurable, poolnetty provides a lot of options for configuration and customisation of the pools\r\nfunction.\r\n\r\n*Note:*\r\nBootStrapProvider and ConnectionInfoProvider need to be implemented, all others have default implementations.\r\n\r\n\r\n<table>\r\n<tr><th>Interface</th><th>Description</th></tr>\r\n<tr><td>BootstrapProvider</td><td>Is called when making a connection to provide a configured bootstrap.</td></tr>\r\n<tr><td>ConnectionInfoProvider</td><td>Is called when making a connection to supply the local and remote addresses and\r\na channel initializer.</td></tr>\r\n<tr><td>ContextExceptionHandler</td><td>Is called when a channel throws an exception, with the option of closing the channel.</td></tr>\r\n<tr><td>LeaseExpiryReaper</td><td>Implementations of this are called to nominate expired leases for later processing.</td></tr>\r\n\r\n<tr><td>LeaseExpiredHandler</td><td>Is called on each expired lease and provides the option of terminating the channel.</td></tr>\r\n\r\n<tr><td>PoolExceptionHandler</td><td>Exception emitted by netty or the pool are funneled through this.</td></tr>\r\n\r\n<tr><td>PoolProviderListener</td><td>Pool listener.</td></tr>\r\n\r\n<tr><td>PostConnectEstablish</td><td>Called once a connection is established and allows users to perform final setup\r\nof the connection. For example logging into the end service at the other end of the connection. Please see the Javadoc.</td></tr>\r\n\r\n<tr><td>PreGrantLease</td><td>Gives users the ability to block the granting of a lease.</td></tr>\r\n<tr><td>PreReturnToPool</td><td>Gives users the chance to make closure decisions on a channel as it returns to the pool.</td></tr>\r\n</table>\r\n\r\n\r\n\r\n## Notes on threading\r\n\r\nThe Pool Provider is a decoupled implementation where a single executor is responsible for executing tasks that provide\r\nthe pools function. Looking at the code there is no synchronisation because the assumption is that everything is\r\nbeing executed on one thread.\r\n\r\nIn some cases rather than block some tasks will defer execution and queue up in a deque or hand themselves to another\r\ntask that they require the completion of. This task will then ensure the dependent task is executed at the appropriate time.\r\n\r\nThe general ambition is to keep the executor service (decoupler) free of obstructions, while endeavouring to move the\r\nblocking tasks are out of the way until they need to modify structures within the pool.\r\n\r\nTo execute a runnable on the Pools decoupler:\r\n\r\n```java\r\n  ncp.execute(new Runnable(){\r\n     public void run(){ .. etc ..  }\r\n  });\r\n```\r\n\r\nThere is one exception to the concurrency model and that is the pool Listeners which use a CopyOnWriteArraySet. This was\r\ndone because it is unlikely that there will be a lot of changes to pool listener list and some events are not fired from\r\nthe decoupler.\r\n\r\nCopyright &copy; 2014 R358 All Rights Reserved\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}